Курсов Проект: Система за 
Организация на Места за Сядане на 
Сватба 
Дисциплина: Софтуерни Шаблони 
Разработил: Васил Василев Василев, ИТИ
1. Въведение и Обхват на Проекта 
Разработеният софтуерен проект представлява система за автоматизирана 
организация на местата за сядане на сватбено тържество. Основната задача 
на приложението е да разпределя семействата по маси, като спазва стриктни 
бизнес правила: максимален капацитет от 10 души на маса, ограничение до 2 
семейства на маса и възможност за дефиниране на забранени комбинации за 
сядане между определени фамилии. 
Системата е изградена на езика Java и използва JavaFX за реализация на 
графичен потребителски интерфейс, което осигурява лесно управление на 
данните и динамичен избор на стратегия за настаняване. 
2. Архитектура на Система и Модел на Класовете 
Архитектурата следва принципите на обектно-ориентираното проектиране и се 
основава на ясно разделение на отговорностите между основните модули. 
2.1. UML Диаграма на Класовете 
Следващата UML диаграма представя статичната структура на класовете, 
интерфейсите и отношенията между тях, като илюстрира приложението на 
ключовите шаблони за проектиране. 
Използвах шаблона Composite, за да третирам семействата и масите по един и 
същи начин. 
И двата класа (Family и Table) имплементират интерфейса GuestComponent. 
Това позволява лесно обхождане и работа с йерархични структури от гости. 
GuestComponent е абстрактен компонент (общ интерфейс). 
Family е „Leaf“ (краен елемент без подкомпоненти). 
Table е „Composite“ (съдържа други GuestComponent елементи). 
Ползва се, за да може една маса и едно семейство да бъдат третирани 
еднакво – например display() се вика рекурсивно. 
GuestIterator (интерфейс) и TableIterator (конкретен итератор). 
Позволяват да се обхождат гостите на масата без да се разкрива 
вътрешната структура на Table.  Така MainGUI или SeatingManager могат 
да обхождат елементи независимо как се съхраняват. 
Имаме интерфейс SeatingStrategy, който дефинира метода arrange(). 
Две различни реализации: BySizeStrategy (по големина) и 
AlphabeticalStrategy (по азбучен ред). 
SeatingContext служи като контекст, който може да сменя стратегията 
динамично (бутон в GUI-то). 
СеатингМанагер не е софтуерен шаблон , но е важен контролер за логиката. 
Съхранява „забранени двойки“ и проверява дали две фамилии могат да 
седят заедно. 
GUI-то извиква forbidTogether(f1, f2) и canSitTogether(f1, f2) при 
нужда. 
MainGUI използва JavaFX: 
Показва таблицата с масите и фамилиите. 
Позволява добавяне на нови семейства. 
Използва SeatingManager за логиката и SeatingContext за 
стратегията на подреждане. 
GuestRow е помощен клас за TableView (Model за GUI таблицата). 
2.2. Iзползвани Шаблони за Проектиране (Design Patterns) 
Системата демонстрира ефективна употреба на три основни шаблона: 
Шабло
 н Цел Участващи класове 
Composite  
Осигурява единно третиране на отделни 
обекти и групи обекти чрез общ интерфейс. 
Позволява структуриране на семейства и 
маси в йерархия. 
GuestComponent, 
Family, Table 
Iterator  
Позволява обхождане на елементите на една 
маса, без да се разкрива вътрешната ѝ 
структура. 
GuestIterator, 
TableIterator 
Strategy  
Дава възможност за динамична смяна на 
алгоритъма за подреждане и сортиране на 
семействата. 
SeatingStrategy, 
AlphabeticalStrateg
 y, BySizeStrategy, 
SeatingContext 
 
3. Детайлно Описание на Ключовите Класове 
Клас / 
Интерфей
 с 
Пакет Роля Ключова Функционалност 
Table wedding.model Композитен 
Контейнер 
Прилага ограниченията за 
капацитет и брой семейства. 
Предоставя 
createIterator(). 
Family wedding.model Лист Елемент 
Съхранява името и броя гости 
на едно семейство. 
SeatingMana
 ger wedding.model Управление на 
Конфликтите 
Съхранява и проверява 
всички забрани за сядане 
(isForbidden()). 
GuestIterat
 or 
wedding.iterat
 or 
Интерфейс на 
Итератора 
Дефинира стандартизирания 
начин за обхождане 
(hasNext(), next()). 
SeatingStra
 tegy 
wedding.strate
 gy 
Интерфейс на 
Стратегията 
Дефинира метода за 
сортиране на семействата 
(arrange()). 
MainGU 
wedding.gui 
Графичен 
Интерфейс 
Основен изпълнителен модул. 
Управлява входните данни и 
изпълнява Greedy алгоритъма. 
4. Алгоритъм за Настаняване и Логика 
Логиката за разпределение се съдържа в метода arrangeAll() на класа MainGUI 
и използва грейди (greedy) подход, който търси оптимално локално решение на 
всяка стъпка: 
1. Приоритизиране (Strategy): Списъкът с всички семейства се сортира 
според избраната стратегия (по подразбиране BySizeStrategy - най
големите семейства първи). 
2. Обхождане: Всяко семейство се обхожда последователно. 
3. Опит за Настаняване: За всяко семейство се прави опит да бъде 
настанено на вече съществуваща маса, която отговаря на следните 
критерии: 
a. Конфликт: Проверка със SeatingManager.isForbidden() спрямо 
всяко семейство, вече настанено на масата. 
b. Капацитет: Проверка, че общият брой гости няма да надхвърли 10 
души. 
c. Лимит на семействата: Проверка, че масата няма да съдържа 
повече от 2 семейства. 
4. Създаване на Нова Маса: Ако не може да бъде настанено на 
съществуваща маса, се създава нова Table инстанция. 
Този подход гарантира, че семействата с по-строги ограничения (напр. по
големите или тези с повече конфликти) получават приоритет при настаняването, 
което повишава вероятността за успешно разпределение. 
5. Графичен Потребителски Интерфейс (GUI) 
Потребителският интерфейс е реализиран с JavaFX (клас MainGUI) и осигурява 
пълен контрол върху входните данни, логиката за настаняване и визуализацията 
на резултата. 
5.1. Ключови Компоненти 
• TableView: Основният изходен компонент. Представя крайния резултат, 
като колоните показват Маса, Семейство и Брой гости. Данните се 
свързват чрез класа-помощник GuestRow. 
• Контроли за Вход: 
o " Добави семейство": Отваря диалогов прозорец, който позволява 
въвеждане на име и брой гости, които се добавят към основния 
списък (allFamilies). 
o " Забрани комбинация": Отваря диалогов прозорец с два падащи 
списъка (ChoiceBox), които позволяват на потребителя да избере 
две семейства и да регистрира конфликт в SeatingManager. 
• ChoiceBox за Стратегия: Позволява динамичен избор на стратегията за 
сортиране преди натискане на бутона за подреждане. 
• ListView за Забрани: Визуализира всички активни забранени 
комбинации, регистрирани в системата. 
5.2. Поток на Работа 
Потребителят въвежда всички семейства и техните конфликти. След това избира 
желаната стратегия и натиска " Подреди масите". Приложението изпълнява 
arrangeAll(), изчиства старите маси и генерира ново разпределение, което се 
визуализира в TableView. 
